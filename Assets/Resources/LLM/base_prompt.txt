### RUNTIME API (Unity Lua Proxies) — READ BEFORE CODING

HARD RULES
- Do NOT call GetComponent / AddComponent / GetComponentInChildren / GetComponentInParent from Lua.
- Do NOT assign C# fields/properties on userdata directly (e.g., `rigidbody.useGravity = true` is INVALID).
- Use only the proxies and methods listed below.
- Transform uses PROPERTIES (set with `=`), not "SetXxx" methods.

Valid examples:
  self.transform.name = "MyObject"
  self.transform.localScale = { x=1, y=1, z=1 }
  self.rigidbody:SetUseGravity(true)
Invalid examples:
  self.transform:SetName("MyObject")
  self.transform:SetLocalScale({x=...,y=...,z=...})
  self.transform:SetColor({...})
  self.rigidbody.useGravity = true

GENERAL
- self.gameObject and self.transform are always available.
- Accessing self.rigidbody / self.audio (audioSource) / self.particles (particleSystem) lazily binds a proxy.
  If missing, the runtime may auto-add a safe default (Rigidbody is kinematic + no gravity by default).
- Always feature-detect: `if self.rigidbody then ... end`.

VECTORS
- Getters like `transform.position` return a Vector3Proxy with fields `x, y, z` (writes write back).
- Setters accept `{ x=..., y=..., z=... }`.

EVENTS TO IMPLEMENT (optional)
- start(self), update(self, dt), on_trigger(self, other), on_collision(self, col), on_stop(self)

----------------------------------------------------------------
PROXIES & METHODS (current runtime)
----------------------------------------------------------------

TransformProxy  (self.transform)
PROPERTIES (set with '='):
- name : string
- position : Vector3Proxy
- localPosition : Vector3Proxy
- localScale : Vector3Proxy
- eulerAngles : Vector3Proxy
METHODS:
- Translate(x, y, z)
- TranslateWorld(x, y, z)
- Rotate(xDeg, yDeg, zDeg)
- RotateWorld(xDeg, yDeg, zDeg)
- LookAt(x, y, z)
NOTE: There is NO SetName / SetLocalScale / SetColor on Transform.

GameObjectProxy  (self.gameObject)
- GetName() -> string
- SetName(name)
- GetTag() -> string
- IsActive() -> bool
- SetActive(bool)
- GetTransformProxy() -> TransformProxy
- HasRigidbody() -> bool
- GetRigidbodyProxy() -> RigidbodyProxy or nil
- GetAudioSourceProxy() -> AudioSourceProxy or nil
- HasParticleSystem() -> bool
- GetParticleSystemProxy() -> ParticleSystemProxy or nil
- GetParticleSystemProxiesInChildren() -> array of ParticleSystemProxy
- GetAnimatorProxy() -> AnimatorProxy or nil
- (Optional helper if present) SetMaterialColor(r,g,b,a?)

RigidbodyProxy  (self.rigidbody)
- SetUseGravity(bool)
- GetUseGravity() -> bool
- GetIsKinematic() -> bool
- SetIsKinematic(bool)        -- alias provided: SetKinematic(bool)
- AddForce(x, y, z[, mode])   -- mode ∈ {"Force","Impulse","Acceleration","VelocityChange"}
- AddImpulse(x, y, z)
- SetVelocity(x, y, z)
- GetVelocity() -> { x, y, z }
- GetMass() -> number
- SetMass(number)

ParticleSystemProxy  (self.particles / self.particleSystem)
- Play()
- Stop()
- Clear()
- IsAlive() -> bool
- SetLooping(bool)

AudioSourceProxy  (self.audio / self.audioSource)
- Play()
- Stop()
- Pause()
- SetVolume(number 0..1)
- SetLoop(bool)

AnimatorProxy  (self.animator)
- Play(stateName)
- SetTrigger(name)
- SetBool(name, bool)
- SetFloat(name, number)
- SetInt(name, int)

ProgramableObjectProxy  (self.programable / self.programmable / self.programableObject)
Identity/flags:
- GetId() -> string
- GetIsRealObject() -> bool
Label/visual:
- SetLabel(text)
- SetColor(r, g, b, a?)      -- use this for color, NOT Transform
Highlight control:
- ToggleLatchedHighlight()
- SetLatchedHighlight(bool)
- ClearLatchedHighlight()
- GetHighlightOnHover() / SetHighlightOnHover(bool)
- GetStickyHighlightEnabled() / SetStickyHighlightEnabled(bool)
Proximity/selection readouts:
- GetIsTouching() -> bool
- GetTouchDistance() / SetTouchDistance(distanceMeters)
- GetIsSelected() -> bool
- GetIsHovering() -> bool

CollisionProxy  (col in on_collision)
- GetGameObject() -> GameObjectProxy
- GetContactPoint() -> Vector3Proxy
- GetContactNormal() -> Vector3Proxy
- GetRelativeVelocity() -> Vector3Proxy
- GetContactCount() -> int
- GetContactPointAt(i) -> Vector3Proxy
- GetRigidbodyProxy() -> RigidbodyProxy or nil

----------------------------------------------------------------
USAGE EXAMPLES (correct patterns)
----------------------------------------------------------------

-- Name & scale via Transform PROPERTIES + color via ProgramableObject
function start(self)
  self.transform.name = "ProgramableObject_Virtual"
  self.transform.localScale = { x = 1, y = 1, z = 1 }

  local po = self.programable or self.programmable or self.programableObject
  if po then po:SetColor(1, 0, 0, 1) end

  dotween:ScaleTo(self.transform, 1.5, 1.5, 1.5, 0.5, 'InOutSine')
end

function update(self, dt)
  local s = self.transform.localScale
  if s.x >= 1.5 then
    dotween:ScaleTo(self.transform, 1, 1, 1, 0.5, 'InOutSine')
  elseif s.x <= 1.0 then
    dotween:ScaleTo(self.transform, 1.5, 1.5, 1.5, 0.5, 'InOutSine')
  end
end

-- Physics via methods only
function start(self)
  if self.rigidbody then
    self.rigidbody:SetUseGravity(true)
    if self.rigidbody.SetIsKinematic then self.rigidbody:SetIsKinematic(false) end
    self.rigidbody:AddForce(0, 2, 0, "Impulse")
  end
end

-- Collision vectors are Vector3Proxy
function on_collision(self, col)
  local v = col:GetRelativeVelocity() -- v.x, v.y, v.z
  -- e.g., react to impact...
end
